1. 基本总结

![截图](../figs/截图.png)

**交叉选归**（比较类）、**计基桶**（选择类）

   
![截图2](../figs/截图2.png)

记住平均就可以把最好和最好记住！！！

**快速排序、归并排序、堆排序** （快归队！）

2. 基本排序
A. 冒泡排序（Bubble Sort）
简介：就像泡泡一样，越往上越大，所以原理就是：每次从左到右两两比较，把大的交换到后面/或者把小的交换到前面。
![bubble](../figs/bubble.gif)
步骤：
a. 从左开始比较相邻的两个元素x和y，如果 x>y 交换。（一层for）
b. 比较和交换，直到到达数组最后一个元素（一层for）
c. 重复执行a和b，直到执行n次，也就是n个最大元素都排到了最后。
有两层for循环，所以时间复杂度为 $O(n^2)$ 。

```python
def bubble_sort(arr):
    #这层循环是让数组每个数字找到位置，减一是因为后n-1排好，剩下的自然归位
    length = len(arr)
    for i in range(length-1):
        # 如果后面没有进行比较，则证明有序，直接返回，不需要再判断
        count = 0
        #这里是将最大的数字往后面冒泡
        for j in range(length-1-i):
            if arr[j] > arr[j+1]:
                arr[j],arr[j+1] = arr[j+1],arr[j]
                count +=1
        if count == 0:
            return
```


​B. 快速排序
​简介：快速排序是利用分治法实现的一种，其主要是选择一个**基准数**，把比这个数小的移到左边，把比这个数大的移到右边。然后分治，不断对左右两边执行相同操作，直到整个数组有序。
![bubble](../figs/quick.gif)
​步骤：
​a. 用一个基准数将数组分成两个子数组
b. 将大于基准数的移到右边，小于基准数的移到左边（从小到大排序）
c. 递归对子数组重复执行a和b，直到整个数组有序

```python
def quick_sort(nums, left, right) {
    int i = left
    int j = right
    int pivot = nums[left]; #设基准数为最左边一个
    while( i < j) {         #每一次while循环下来会把小于/大于“当前基准数”的全部排到左边或者右边
        while(i < j and nums[j] >= pivot) j-=1;  #从右边开始，找到第一个比基准数小的（如果大就让它一直循环）
        if(i < j) nums[i] = nums[j]
        while(i < j and nums[i] <= pivot) i+=1;  #从左边开始，找到第一个比基准数大的（如果小就让它一直循环）
        if(i < j) nums[i] = nums[j]
    }
    #上面循环之后，最终i和j会一起停留在基准数上面。
    nums[i] = pivot
    quick_sort(nums,left,i-1);   #对左半边 nums[left...i-1]排序,分治
    quick_sort(nums,j+1,right);  #对右半边 nums[j+1...right]排序,分治
}
```

​		C. 直接插入排序

​		简介：插入排序是从左到右，把选出的一个数和前面的数进行比较，找到适合它的位置插入，使得前面的部分有序。它是由两层嵌套循环组成的。

​		步骤：

​		a. 从左开始，选出当前位置的数x，和它之前的数y作比较，如果x<y，则交换

​		b. 对x之前的数都执行a操作，直到前面的数字都有序

​		c. 选择有序部分后的一个数字，插入到前面有序部分，直到没有数字可以选择。

```C++
// 插入
template<class T>
void insert_sort(vector<T> &nums) {
    int insertNum;
    for(int i = 1;i < nums.size(); i++) {
        insertNum = nums[i];
        for (int j = i; j > 0; j--) {
            if(insertNum < nums[j]) {
                nums[j] = nums[j-1];  //把所有大的数往后移动，这会覆盖插入的数，所以需要定义一个
            }
        }
        nums[j] = insertNum;  //
    }
}
```

​		D. 二分插入排序

​		折半查找法的使用是二分插入排序与直接插入排序的区别。

```C++
// 二分插入排序,原来色插入排序是需要遍历所有的数,二分插入将遍历折半
template<class T>
void BinaryInsertSort(vector<T> &nums) {
    int middle;
    for (int i = 0; i < nums.size(); i++)
    {
        int insertNum = nums[i];
        int left = 0;
        int right = i-1;
        // 每次都通过将整个数组折半，通过二分法来查找插入位置，原来的方法是从后面开始一一比较
        while(left <= right) {
            middle = (left+right)/2;
            if(insertNum > nums[middle]) left = middle+1;  //插入的数大于中间的数，需要插入到右边
            if(insertNum < nums[middle]) right = middle-1;  //插入的数小于中间的数，需要插入到左边
        }
        for (int j = i; j > left; j--)   
        {
            nums[j] = nums[j-1];
        }
        nums[left] = insertNum;
    }
    
}
```

​		D. 希尔排序

​		简介：希尔排序可以看做是插入排序的优化版，因为插入排序需要一位一位比较，然后放置到正确的位置，为了提升比较的跨度，希尔排序将数组按照一定的步长分成几个子数组进行比较，通过**缩短增量**来完成最终排序。一般先去 $gap=gap/2$（向上取整）

​		步骤：

​		a. 计算当前步长，按照步长划分子数组

​		b. 子数组内插入排序

​		c. 步长除以2后继续a,b两步，直到最后步长为1

​		举例：

​		以 $[20,37,50,35,10,1]$ 为例子，一共有6个元素，所以分为 $6/2=3$ 组，每组有两个元素[20,35],[37,10],[50,1]，然后对每一组进行直接插入排序，得到 $[20,35,10,37,1,50]$

